/*
 * Copyright (c) 2012. Humboldt-Universit√§t zu Berlin, Dept. of Computer Science and Dept.
 * of Wissensmanagement in der Bioinformatik
 * -------------------------------
 *
 * THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS COMMON PUBLIC
 * LICENSE ("AGREEMENT"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM
 * CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
 *
 * 1. DEFINITIONS
 *
 * "Contribution" means:
 *
 * a) in the case of the initial Contributor, the initial code and
 * documentation distributed under this Agreement, and
 *
 * b) in the case of each subsequent Contributor:
 *
 * i) changes to the Program, and
 *
 * ii) additions to the Program;
 *
 * where such changes and/or additions to the Program originate from and are
 * distributed by that particular Contributor. A Contribution 'originates' from a
 * Contributor if it was added to the Program by such Contributor itself or anyone
 * acting on such Contributor's behalf. Contributions do not include additions to
 * the Program which: (i) are separate modules of software distributed in
 * conjunction with the Program under their own license agreement, and (ii) are not
 * derivative works of the Program.
 *
 * "Contributor" means any person or entity that distributes the Program.
 *
 * "Licensed Patents " mean patent claims licensable by a Contributor which are
 * necessarily infringed by the use or sale of its Contribution alone or when
 * combined with the Program.
 *
 * "Program" means the Contributions distributed in accordance with this Agreement.
 *
 * "Recipient" means anyone who receives the Program under this Agreement,
 * including all Contributors.
 *
 * 2. GRANT OF RIGHTS
 *
 * a) Subject to the terms of this Agreement, each Contributor hereby grants
 * Recipient a non-exclusive, worldwide, royalty-free copyright license to
 * reproduce, prepare derivative works of, publicly display, publicly perform,
 * distribute and sublicense the Contribution of such Contributor, if any, and such
 * derivative works, in source code and object code form.
 *
 * b) Subject to the terms of this Agreement, each Contributor hereby grants
 * Recipient a non-exclusive, worldwide, royalty-free patent license under Licensed
 * Patents to make, use, sell, offer to sell, import and otherwise transfer the
 * Contribution of such Contributor, if any, in source code and object code form.
 * This patent license shall apply to the combination of the Contribution and the
 * Program if, at the time the Contribution is added by the Contributor, such
 * addition of the Contribution causes such combination to be covered by the
 * Licensed Patents. The patent license shall not apply to any other combinations
 * which include the Contribution. No hardware per se is licensed hereunder.
 *
 * c) Recipient understands that although each Contributor grants the licenses
 * to its Contributions set forth herein, no assurances are provided by any
 * Contributor that the Program does not infringe the patent or other intellectual
 * property rights of any other entity. Each Contributor disclaims any liability to
 * Recipient for claims brought by any other entity based on infringement of
 * intellectual property rights or otherwise. As a condition to exercising the
 * rights and licenses granted hereunder, each Recipient hereby assumes sole
 * responsibility to secure any other intellectual property rights needed, if any.
 * For example, if a third party patent license is required to allow Recipient to
 * distribute the Program, it is Recipient's responsibility to acquire that license
 * before distributing the Program.
 *
 * d) Each Contributor represents that to its knowledge it has sufficient
 * copyright rights in its Contribution, if any, to grant the copyright license set
 * forth in this Agreement.
 *
 * 3. REQUIREMENTS
 *
 * A Contributor may choose to distribute the Program in object code form under its
 * own license agreement, provided that:
 *
 * a) it complies with the terms and conditions of this Agreement; and
 *
 * b) its license agreement:
 *
 * i) effectively disclaims on behalf of all Contributors all warranties and
 * conditions, express and implied, including warranties or conditions of title and
 * non-infringement, and implied warranties or conditions of merchantability and
 * fitness for a particular purpose;
 *
 * ii) effectively excludes on behalf of all Contributors all liability for
 * damages, including direct, indirect, special, incidental and consequential
 * damages, such as lost profits;
 *
 * iii) states that any provisions which differ from this Agreement are offered
 * by that Contributor alone and not by any other party; and
 *
 * iv) states that source code for the Program is available from such
 * Contributor, and informs licensees how to obtain it in a reasonable manner on or
 * through a medium customarily used for software exchange.
 *
 * When the Program is made available in source code form:
 *
 * a) it must be made available under this Agreement; and
 *
 * b) a copy of this Agreement must be included with each copy of the Program.
 *
 * Contributors may not remove or alter any copyright notices contained within the
 * Program.
 *
 * Each Contributor must identify itself as the originator of its Contribution, if
 * any, in a manner that reasonably allows subsequent Recipients to identify the
 * originator of the Contribution.
 *
 * 4. COMMERCIAL DISTRIBUTION
 *
 * Commercial distributors of software may accept certain responsibilities with
 * respect to end users, business partners and the like. While this license is
 * intended to facilitate the commercial use of the Program, the Contributor who
 * includes the Program in a commercial product offering should do so in a manner
 * which does not create potential liability for other Contributors. Therefore, if
 * a Contributor includes the Program in a commercial product offering, such
 * Contributor ("Commercial Contributor") hereby agrees to defend and indemnify
 * every other Contributor ("Indemnified Contributor") against any losses, damages
 * and costs (collectively "Losses") arising from claims, lawsuits and other legal
 * actions brought by a third party against the Indemnified Contributor to the
 * extent caused by the acts or omissions of such Commercial Contributor in
 * connection with its distribution of the Program in a commercial product
 * offering. The obligations in this section do not apply to any claims or Losses
 * relating to any actual or alleged intellectual property infringement. In order
 * to qualify, an Indemnified Contributor must: a) promptly notify the Commercial
 * Contributor in writing of such claim, and b) allow the Commercial Contributor to
 * control, and cooperate with the Commercial Contributor in, the defense and any
 * related settlement negotiations. The Indemnified Contributor may participate in
 * any such claim at its own expense.
 *
 * For example, a Contributor might include the Program in a commercial product
 * offering, Product X. That Contributor is then a Commercial Contributor. If that
 * Commercial Contributor then makes performance claims, or offers warranties
 * related to Product X, those performance claims and warranties are such
 * Commercial Contributor's responsibility alone. Under this section, the
 * Commercial Contributor would have to defend claims against the other
 * Contributors related to those performance claims and warranties, and if a court
 * requires any other Contributor to pay any damages as a result, the Commercial
 * Contributor must pay those damages.
 *
 * 5. NO WARRANTY
 *
 * EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS PROVIDED ON AN
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR
 * IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE,
 * NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each
 * Recipient is solely responsible for determining the appropriateness of using and
 * distributing the Program and assumes all risks associated with its exercise of
 * rights under this Agreement, including but not limited to the risks and costs of
 * program errors, compliance with applicable laws, damage to or loss of data,
 * programs or equipment, and unavailability or interruption of operations.
 *
 * 6. DISCLAIMER OF LIABILITY
 *
 * EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER RECIPIENT NOR ANY
 * CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST
 * PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS
 * GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 *
 * 7. GENERAL
 *
 * If any provision of this Agreement is invalid or unenforceable under applicable
 * law, it shall not affect the validity or enforceability of the remainder of the
 * terms of this Agreement, and without further action by the parties hereto, such
 * provision shall be reformed to the minimum extent necessary to make such
 * provision valid and enforceable.
 *
 * If Recipient institutes patent litigation against a Contributor with respect to
 * a patent applicable to software (including a cross-claim or counterclaim in a
 * lawsuit), then any patent licenses granted by that Contributor to such Recipient
 * under this Agreement shall terminate as of the date such litigation is filed. In
 * addition, if Recipient institutes patent litigation against any entity
 * (including a cross-claim or counterclaim in a lawsuit) alleging that the Program
 * itself (excluding combinations of the Program with other software or hardware)
 * infringes such Recipient's patent(s), then such Recipient's rights granted under
 * Section 2(b) shall terminate as of the date such litigation is filed.
 *
 * All Recipient's rights under this Agreement shall terminate if it fails to
 * comply with any of the material terms or conditions of this Agreement and does
 * not cure such failure in a reasonable period of time after becoming aware of
 * such noncompliance. If all Recipient's rights under this Agreement terminate,
 * Recipient agrees to cease use and distribution of the Program as soon as
 * reasonably practicable. However, Recipient's obligations under this Agreement
 * and any licenses granted by Recipient relating to the Program shall continue and
 * survive.
 *
 * Everyone is permitted to copy and distribute copies of this Agreement, but in
 * order to avoid inconsistency the Agreement is copyrighted and may only be
 * modified in the following manner. The Agreement Steward reserves the right to
 * publish new versions (including revisions) of this Agreement from time to time.
 * No one other than the Agreement Steward has the right to modify this Agreement.
 * IBM is the initial Agreement Steward. IBM may assign the responsibility to serve
 * as the Agreement Steward to a suitable separate entity. Each new version of the
 * Agreement will be given a distinguishing version number. The Program (including
 * Contributions) may always be distributed subject to the version of the Agreement
 * under which it was received. In addition, after a new version of the Agreement
 * is published, Contributor may elect to distribute the Program (including its
 * Contributions) under the new version. Except as expressly stated in Sections
 * 2(a) and 2(b) above, Recipient receives no rights or licenses to the
 * intellectual property of any Contributor under this Agreement, whether
 * expressly, by implication, estoppel or otherwise. All rights in the Program not
 * expressly granted under this Agreement are reserved.
 *
 * This Agreement is governed by the laws of the State of New York and the
 * intellectual property laws of the United States of America. No party to this
 * Agreement will bring a legal action under this Agreement more than one year
 * after the cause of action arose. Each party waives its rights to a jury trial in
 * any resulting litigation.
 */

package de.berlin.hu.chemspot;

import de.berlin.hu.types.PubmedDocument;
import de.berlin.hu.uima.cc.eval.ComparableAnnotation;
import de.berlin.hu.wbi.common.research.Evaluator;
import org.apache.uima.UIMAException;
import org.apache.uima.analysis_engine.AnalysisEngine;
import org.apache.uima.analysis_engine.AnalysisEngineProcessException;
import org.apache.uima.examples.SourceDocumentInformation;
import org.apache.uima.jcas.JCas;
import org.apache.uima.resource.metadata.TypeSystemDescription;
import org.u_compare.shared.semantic.NamedEntity;
import org.u_compare.shared.syntactic.Token;
import org.uimafit.factory.AnalysisEngineFactory;
import org.uimafit.factory.JCasFactory;
import org.uimafit.factory.TypeSystemDescriptionFactory;
import org.uimafit.util.JCasUtil;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.zip.GZIPInputStream;

public class ChemSpot {
    private TypeSystemDescription typeSystem;
    private AnalysisEngine sentenceDetector;
    private AnalysisEngine sentenceConverter;
    private AnalysisEngine bannerTagger;
    private AnalysisEngine linnaeusTagger;
    private AnalysisEngine annotationMerger;
    private AnalysisEngine fineTokenizer;
    private AnalysisEngine stopwordFilter;
    private AnalysisEngine normalizer;

    /**
     * Initializes ChemSpot without a dictionary automaton.
     * @param pathToModelFile the Path to a CRF model
     */
    public ChemSpot(String pathToModelFile) {
        new ChemSpot(pathToModelFile, "");
    }

    /**
     * Initializes ChemSpot with a CRF model and a dictionary automaton.
     * @param pathToModelFile the path to a CRF model
     * @param pathToDictionaryFile the ath to a dictionary automaton
     */
    public ChemSpot(String pathToModelFile, String pathToDictionaryFile) {
        try {
            //FIXME: find a way to access the descriptors in the jar rather than outside
            typeSystem = TypeSystemDescriptionFactory.createTypeSystemDescription("desc/TypeSystem");
            fineTokenizer = AnalysisEngineFactory.createAnalysisEngine("desc/ae/tokenizer/FineGrainedTokenizerAE");
            sentenceDetector = AnalysisEngineFactory.createAnalysisEngine("desc/ae/tagger/opennlp/SentenceDetector");
            sentenceConverter = AnalysisEngineFactory.createAnalysisEngine("desc/ae/converter/OpenNLPToUCompareSentenceConverterAE");
            System.out.println("Loading CRF...");
            bannerTagger = AnalysisEngineFactory.createAnalysisEngine("desc/banner/tagger/BANNERTaggerAE", "BannerModelFile", pathToModelFile);
            if (pathToDictionaryFile!= null) System.out.println("Loading dictionary..."); else System.out.println("No dictionary location specified! Tagging without dictionary...");
            if (pathToDictionaryFile != null) linnaeusTagger = AnalysisEngineFactory.createAnalysisEngine("desc/ae/tagger/DictionaryTaggerAE", "DrugBankMatcherDictionaryAutomat", pathToDictionaryFile);
            annotationMerger = AnalysisEngineFactory.createAnalysisEngine("desc/ae/AnnotationMergerAE");
            normalizer = AnalysisEngineFactory.createAnalysisEngine("desc/ae/normalizer/IUPACToInChIAE");
            stopwordFilter = AnalysisEngineFactory.createAnalysisEngine("desc/ae/filter/StopwordFilterAE");
            System.out.println("Finished initializing ChemSpot.");
        } catch (UIMAException e) {
            System.err.println("Failed initializing ChemSpot.");
            e.printStackTrace();
        } catch (IOException e) {
            System.err.println("Failed initializing ChemSpot.");
            e.printStackTrace();
        }
    }

    /**
     * Finds chemical entities in the document of a {@code JCas} object and returns a list of mentions.
     * @param jcas contains the document text
     * @return a list of mentions
     */
    private List<Mention> tag(JCas jcas) {
        try {
            fineTokenizer.process(jcas);
            sentenceDetector.process(jcas);
            sentenceConverter.process(jcas);
            bannerTagger.process(jcas);
            if (linnaeusTagger != null) linnaeusTagger.process(jcas);
            annotationMerger.process(jcas);
            normalizer.process(jcas);
            stopwordFilter.process(jcas);

            List<Mention> mentions = new ArrayList<Mention>();
            Iterator<NamedEntity> entities = JCasUtil.iterator(jcas, NamedEntity.class);
            while (entities.hasNext()) {
                NamedEntity entity = entities.next();
                //disregards gold-standard mentions
                if (!"goldstandard".equals(entity.getSource())) {
                    mentions.add(new Mention(entity.getBegin(), entity.getEnd(), entity.getCoveredText(), entity.getId(), entity.getSource()));
                }
            }
            return mentions;
        } catch (AnalysisEngineProcessException e) {
            System.err.println("Failed to extract chemicals from text.");
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Finds chemical entities in a {@code text} and returns a list of mentions.
     * @param text natural language text from which ChemSpot shall extract chemical entities
     * @return a list of mentions
     */
    public List<Mention> tag(String text) {
        try {
            JCas jcas = JCasFactory.createJCas(typeSystem);
            jcas.setDocumentText(text);
            PubmedDocument pd = new PubmedDocument(jcas);
            pd.setBegin(0);
            pd.setEnd(text.length());
            pd.setPmid("");
            pd.addToIndexes(jcas);
            return tag(jcas);
        } catch (UIMAException e) {
            System.err.println("Failed to extract chemicals from text.");
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Finds chemical entities in a {@code text} and returns the output in IOB format.
     * @param text natural language text from which you want to extract chemical entities
     * @return a string representing the output in IOB format
     * @throws UIMAException
     */
    public String tagReturnIOB(String text) throws UIMAException {
        JCas jcas = JCasFactory.createJCas(typeSystem);
        jcas.setDocumentText(text);
        PubmedDocument pd = new PubmedDocument(jcas);
        pd.setBegin(0);
        pd.setEnd(text.length());
        pd.setPmid("");
        pd.addToIndexes(jcas);
        return tagJCas(jcas, false, true);
    }

    /**
     * Finds chemical entities in a zipped file containing a corpus in MutationFinder format. Subsequently, annotations are written in "{@code pathToGZ}".chemical using the same format.
     * @param pathToGZ the path to a zipped MutationFinder corpus.
     * @throws UIMAException
     * @throws FileNotFoundException
     * @throws IOException
     */
    public void tagGZ(String pathToGZ) throws UIMAException, IOException {
        JCas jcas = JCasFactory.createJCas(typeSystem);
        readGZFile(jcas, pathToGZ);
        tagJCas(jcas, false, false);
        serializeAnnotations(jcas);
    }

    /**
     * Finds chemical entities in the document text of a {@code JCas} object. If gold-standard annotations were provided, it can calculate precision, recall and F measure or return the annotated text in IOB format.
     * @param jcas contains the document text
     * @param evaluate whether to evaluate if gold-standard entities were provided
     * @param convertToIOB whether to return a String representing annotations in IOB format
     * @return a string representing the output in IOB format
     * @throws AnalysisEngineProcessException
     */
    //FIXME: split this method in two parts: tagging and writing IOB
    public String tagJCas(JCas jcas, boolean evaluate, boolean convertToIOB) throws AnalysisEngineProcessException {
        //TODO change to buffered string builder!
        StringBuilder sb = new StringBuilder();
        fineTokenizer.process(jcas);
        sentenceDetector.process(jcas);
        sentenceConverter.process(jcas);
        bannerTagger.process(jcas);
        if (linnaeusTagger != null) linnaeusTagger.process(jcas);
        annotationMerger.process(jcas);
        normalizer.process(jcas);
        stopwordFilter.process(jcas);

        HashMap<String, ArrayList<NamedEntity>> goldAnnotations = new HashMap<String, ArrayList<NamedEntity>>();
        HashMap<String, ArrayList<NamedEntity>> pipelineAnnotations = new HashMap<String, ArrayList<NamedEntity>>();

        if (convertToIOB) {
            System.out.println("Converting annotations to IOB format...");
            Iterator<PubmedDocument> abstracts = JCasUtil.iterator(jcas, PubmedDocument.class);

            while (abstracts.hasNext()) {
                PubmedDocument pubmedAbstract = abstracts.next();
                sb.append("### ").append(pubmedAbstract.getPmid()).append("\n");
                int offset = pubmedAbstract.getBegin();
                String pmid = pubmedAbstract.getPmid();

                List<Token> tokens = JCasUtil.selectCovered(Token.class, pubmedAbstract);
                for (Token token : tokens) {
                    token.setLabel("O");
                }

                List<NamedEntity> entities = JCasUtil.selectCovered(NamedEntity.class, pubmedAbstract);
                for (NamedEntity entity : entities) {
                    int firstTokenBegin = 0;
                    int lastTokenEnd = 0;

                    String id = entity.getId();
                    if (id == null) id = "";
                    if (!"goldstandard".equals(entity.getSource())) {
                        if (pipelineAnnotations.containsKey(pmid)) {
                            pipelineAnnotations.get(pmid).add(entity);
                        } else {
                            ArrayList<NamedEntity> tempArray = new ArrayList<NamedEntity>();
                            tempArray.add(entity);
                            pipelineAnnotations.put(pmid, tempArray);
                        }
                        List<Token> entityTokens = JCasUtil.selectCovered(Token.class, entity);
                        boolean first = true;
                        for (Token token : entityTokens) {
                            if (first) {
                                if (id.isEmpty()) token.setLabel("B-CHEMICAL"); else token.setLabel("B-CHEMICAL" + "\t" + id);
                                first = false;
                                firstTokenBegin = token.getBegin();
                            } else {
                                token.setLabel("I-CHEMICAL" + "\t" + id);
                            }
                            lastTokenEnd = token.getEnd();
                        }
                        assert entity.getBegin() == firstTokenBegin : (id + ": " + entity.getBegin() + " -> " + firstTokenBegin);
                        assert entity.getEnd() == lastTokenEnd : (id + ": " + entity.getEnd() + " -> " + lastTokenEnd);
                    } else {
                        if (goldAnnotations.containsKey(pmid)) {
                            goldAnnotations.get(pmid).add(entity);
                        } else {
                            ArrayList<NamedEntity> tempArray = new ArrayList<NamedEntity>();
                            tempArray.add(entity);
                            goldAnnotations.put(pmid, tempArray);
                        }
                    }
                }

                List<Token> tokensToPrint = JCasUtil.selectCovered(Token.class, pubmedAbstract);
                boolean firstToken = true;
                for (Token token : tokensToPrint) {
                    if (firstToken && (token.getBegin() - offset) != 0) {
                        sb.append(" " + "\t" + 0 + "\t").append(token.getBegin() - offset).append("\t\t|O\n");
                    }
                    firstToken = false;
                    sb.append(token.getCoveredText()).append("\t").append(token.getBegin() - offset).append("\t").append(token.getEnd() - offset).append("\t\t|").append(token.getLabel()).append("\n");
                }
            }
        }

        if (evaluate) {
            System.out.println("Starting evaluation...");
            evaluate(goldAnnotations, pipelineAnnotations);
        }
        return sb.toString();
    }

    private int TP = 0;
    private int FP = 0;
    private int FN = 0;

    //FIXME: use Mention instead of NamedEntity
    private void evaluate(HashMap<String, ArrayList<NamedEntity>> goldAnnotations, HashMap<String, ArrayList<NamedEntity>> pipelineAnnotations) {
        List<ComparableAnnotation> goldAnnoationsComparable = new ArrayList<ComparableAnnotation>();
        List<ComparableAnnotation> pipelineAnnotationsComparable = new ArrayList<ComparableAnnotation>();

        for (String pmid : goldAnnotations.keySet()) {
            for (NamedEntity namedEntity : goldAnnotations.get(pmid)) {
                goldAnnoationsComparable.add(ComparableAnnotation.createInstance(namedEntity.getBegin(), namedEntity.getEnd(), namedEntity.getCoveredText(), 0, namedEntity.getCAS(), pmid));
            }
        }
        for (String pmid : pipelineAnnotations.keySet()) {
            for (NamedEntity namedEntity : pipelineAnnotations.get(pmid)) {
                pipelineAnnotationsComparable.add(ComparableAnnotation.createInstance(namedEntity.getBegin(), namedEntity.getEnd(), namedEntity.getCoveredText(), 0, namedEntity.getCAS(), pmid));
            }
        }

        if (goldAnnoationsComparable.size() == 0) {
            FP += pipelineAnnotationsComparable.size();
        } else if (pipelineAnnotationsComparable.size() == 0) {
            FN += goldAnnoationsComparable.size();
        } else {
            Evaluator<ComparableAnnotation,ComparableAnnotation> evaluator = new Evaluator<ComparableAnnotation,ComparableAnnotation>(pipelineAnnotationsComparable, goldAnnoationsComparable);
            evaluator.evaluate();

            TP += evaluator.getTruePositives().size();
            FP += evaluator.getFalsePositives().size();
            FN += evaluator.getFalseNegatives().size();

            System.out.format("True Positives:\t\t%d\nFalse Positives:\t%d\nFalse Negatives:\t%d\n", TP, FP, FN);
            double precision = (double) TP / ((double) TP + FP);
            double recall = (double) TP / ((double) TP + FN);
            double fscore = 2 * (precision * recall) / (precision + recall);
            System.out.format("Precision:\t\t%f\nRecall:\t\t\t%f\nF1 Score:\t\t%f\n", precision, recall, fscore);
            System.out.println();
        }
    }

    private static void readGZFile(JCas jcas, String pathToFile) throws IOException {
        File file = new File(pathToFile);
        String text;
        BufferedReader reader = new BufferedReader(
                new InputStreamReader(
                        new GZIPInputStream(
                                new FileInputStream(file)) ) );

        StringBuilder textBuffer = new StringBuilder();
        Integer currindex = -1;
        while(reader.ready()){
            PubmedDocument pmdoc = new PubmedDocument(jcas);
            String s = reader.readLine();
            if (s != null) {
                //split line into pmid and text
                //String[] two = new String[2];
                String pmid = s.substring(0, s.indexOf("\t"));
                String annot = s.substring(s.indexOf("\t"));
                //two = splitFirst(s, "\t");
                pmdoc.setPmid(pmid);

                //String annot = new String(two[1]);
                //append text
                textBuffer.append(annot).append("\n");
                pmdoc.setBegin(currindex + 1);
                Integer len = annot.length();
                currindex = currindex + len + 1;
                pmdoc.setEnd(currindex);
                pmdoc.addToIndexes();
            }
        }

        text = textBuffer.toString();

        //put document in CAS
        jcas.setDocumentText(text);
        SourceDocumentInformation srcDocInfo = new SourceDocumentInformation(jcas);
        srcDocInfo.setUri(file.getAbsoluteFile().toURI().toString());
        srcDocInfo.setOffsetInSource(0);
        srcDocInfo.setDocumentSize((int) file.length());
        srcDocInfo.setBegin(0);
        srcDocInfo.setEnd(currindex);
        srcDocInfo.addToIndexes();
    }

    private static void serializeAnnotations(JCas jcas) throws IOException {
        Iterator<SourceDocumentInformation> srcIterator = JCasUtil.iterator(jcas, SourceDocumentInformation.class);
        SourceDocumentInformation src = srcIterator.next();
        String pathToFile = src.getUri().replaceFirst("file:", "") + ".chem";

        File file = new File(pathToFile);
        file.createNewFile(); //overwrite if file already exists
        FileWriter writer = new FileWriter(file);

        int offset;

        Iterator<PubmedDocument> documentIterator = JCasUtil.iterator(jcas, PubmedDocument.class);
        while (documentIterator.hasNext()) {
            PubmedDocument document = documentIterator.next();
            offset = document.getBegin();
            String pmid = document.getPmid();
            int numberOfEntities = 0;
            Iterator<NamedEntity> entityIterator = JCasUtil.iterator(document, NamedEntity.class, true, true);
            while (entityIterator.hasNext()) {
                NamedEntity entity = entityIterator.next();
                if (!"goldstandard".equals(entity.getSource())) {
                    int begin = entity.getBegin() - offset;
                    int end = entity.getEnd() - offset - 1;
                    String id = entity.getId();
                    String text = entity.getCoveredText();
                    if (id == null || id.isEmpty()) {
                        writer.write(pmid + "\t" + begin + "\t" + end + "\t" + text + "\t" + "\\N\n");
                    } else {
                        writer.write(pmid + "\t" + begin + "\t" + end + "\t" + text + "\t" + id + "\n");
                    }
                }
                numberOfEntities++;
            }
            if (numberOfEntities == 0) {
                writer.write(pmid + "\t-1\t-1\t\\N\t\\N\n");
            }
        }
        writer.close();
    }
}
